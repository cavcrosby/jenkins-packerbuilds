#!/bin/bash
#
# Main build step should run this script when constructing
# a 'packerbuilds' build.

#######################################
# Checks to see if env vars that are passed
# in are defined in the global environment.
# Globals:
#	PROGRAM_NAME
# Outputs:
#	- error messages, stdout
# Returns:
#   0 - all env vars passed in are defined
#   1 - at least one env var passed in is not defined
#######################################
# credits go to:
# https://stackoverflow.com/questions/29278743/how-to-check-if-multiple-variables-are-defined-or-not-in-bash#answer-65396324
checkvars() {
    var_names=("$@")
    # ndefined ==> not defined
    for var_name in "${var_names[@]}"; do
        [ -z "${!var_name}" ] && echo "${PROGRAM_NAME}: $var_name is not defined" && var_ndefined="true"
    done
    if [ -n "$var_ndefined" ]; then
        return 1
    fi
    return 0
}

#######################################
# Main build script for 'packerbuilds' project
# that is hosted on a jenkins instance.
# Globals:
#   WORKSPACE                           (pre-defined)
#   OS_BUILD_CONFS_BRANCH               (from .env)
#   SHELL_PROVISIONERS_BRANCH           (from .env)
#   SHELL_PROVISIONERS_ENV_FILE_NAME    (from .env)
#   PACKER_BUILD_TEMPLATES_BRANCH       (from .env)
#   PACKER_EXE                          (from .env)
#   ISO_IMAGES_PATH                     (from .env)
#   PROJECT_SCRIPTS_DIRECTORY           (from .env)
#   PACKER_HTTP_DIR_NAME                (from .env)
#   PACKER_SHELL_PROVISIONERS_DIR_NAME  (from .env)
#   OPERATING_SYSTEM                    (from jenkin parameters)
#   OPERATING_SYSTEM_VERSION            (from jenkin parameters)
#   GUEST_OS_TYPE                       (from jenkin parameters)
#   ISO_FILE                            (from jenkin parameters)
#   PACKER_BUILDER                      (from jenkin parameters)
#   OTHER_PACKERBUILD_NAME_CRITERIA     (from jenkin parameters)
#   RECORD_BUILDENV_VARS                (from jenkin parameters)
#   DRY_RUN                             (from jenkin parameters)
#   OS_BUILD_CONF_NAME                  (from jenkin parameters)
#   PACKER_BUILD_TEMPLATE_NAME          (from jenkin parameters)
#   PACKER_BUILD_EVALUSERVARS_NAME      (from jenkin parameters)
#   SHELL_PROVISIONER_NAME              (from jenkin parameters)
# Outputs:
#   - git commands output to stdout/stderr
#   - unix command output to stdout/stderr
#   - packer output to stdout/stderr
#######################################
packerbuilds() {
    # it's assumed jenkins will call bash with flags -xe
    cd "$WORKSPACE" || return 1
    PROGRAM_NAME="packerbuilds"
    PACKERBUILDS_CONF_PATH="${WORKSPACE}/packerbuilds.conf"
    OS_BUILD_CONFS_REPO_URL="https://github.com/cavcrosby/os-build-confs"
    SHELL_PROVISIONERS_REPO_URL="https://github.com/cavcrosby/packer-build-shell-provisioners"
    PACKER_BUILD_TEMPLATES_REPO_URL="https://github.com/cavcrosby/packer-build-templates"
    OS_BUILD_CONFS_REPO_NAME="$(basename "$OS_BUILD_CONFS_REPO_URL")"
    SHELL_PROVISIONERS_REPO_NAME="$(basename "$SHELL_PROVISIONERS_REPO_URL")"
    PACKER_BUILD_TEMPLATES_REPO_NAME="$(basename "$PACKER_BUILD_TEMPLATES_REPO_URL")"
    ENV_VAR_NAMES_NEEDED=(
        OS_BUILD_CONF_NAME
        PACKER_BUILD_TEMPLATE_NAME
        PACKER_BUILD_EVALUSERVARS_NAME
        SHELL_PROVISIONER_NAME
    )

    if [ -d "$OS_BUILD_CONFS_REPO_NAME" ]; then
        rm --recursive --force "$OS_BUILD_CONFS_REPO_NAME"
    fi
    git clone --branch "$OS_BUILD_CONFS_BRANCH" "$OS_BUILD_CONFS_REPO_URL" "$OS_BUILD_CONFS_REPO_NAME"
    if [ -d "$SHELL_PROVISIONERS_REPO_NAME" ]; then
        rm --recursive --force "$SHELL_PROVISIONERS_REPO_NAME"
    fi
    git clone --branch "$SHELL_PROVISIONERS_BRANCH" "$SHELL_PROVISIONERS_REPO_URL" "$SHELL_PROVISIONERS_REPO_NAME"
    if [ -d "$PACKER_BUILD_TEMPLATES_REPO_NAME" ]; then
        rm --recursive --force "$PACKER_BUILD_TEMPLATES_REPO_NAME"
    fi
    git clone --branch "$PACKER_BUILD_TEMPLATES_BRANCH" "$PACKER_BUILD_TEMPLATES_REPO_URL" "$PACKER_BUILD_TEMPLATES_REPO_NAME"
    
    # NOTE: some OS versions contain the dot character in them (usually more than one).
    # To be used as the default hostname for the VM, those will need to be replaced.
    # If it was not clear, PACKERBUILDS_BUILD_NAME is used as the VM hostname.
    PACKERBUILDS_BUILD_NAME=${PACKER_BUILDER}-${OPERATING_SYSTEM}-"$(tr '.' '-' <<< "${OPERATING_SYSTEM_VERSION}")"
    if [ -n "$OTHER_PACKERBUILD_NAME_CRITERIA" ]; then
        PACKERBUILDS_BUILD_NAME="${PACKERBUILDS_BUILD_NAME}-${OTHER_PACKERBUILD_NAME_CRITERIA}"
    fi
    if [ -d "$PACKERBUILDS_BUILD_NAME" ]; then
        rm --recursive --force "$PACKERBUILDS_BUILD_NAME"
    fi

    # we don't want to run packer unless we know we have everything we need
    if ! checkvars "${ENV_VAR_NAMES_NEEDED[@]}"; then
        return 1
    fi

    # NOTE: these might get used in the future, if I intend on identifying 
    # ISO files or checking by their checksums. Would have to manage/fetch 
    # official checksums from sources.
    read -r ISO_CHECKSUM IGNORE <<< "$(sha256sum "${ISO_IMAGES_PATH}/${ISO_FILE}")" # output from sha256sum: hash iso_filename

    PACKER_HTTP_PATH="${WORKSPACE}/${PACKERBUILDS_BUILD_NAME}/${PACKER_HTTP_DIR_NAME}"
    PACKER_SHELL_PROVISIONER_PATH="${WORKSPACE}/${PACKERBUILDS_BUILD_NAME}/${PACKER_SHELL_PROVISIONERS_DIR_NAME}"
    PACKER_BUILD_ROOT_PATH="${WORKSPACE}/${PACKERBUILDS_BUILD_NAME}"
    mkdir --parents "$PACKER_HTTP_PATH"
    mkdir --parents "$PACKER_SHELL_PROVISIONER_PATH"

    # Create a packerbuilds dir that will serve files over http and allocate
    # further configurations via shell provisioners.
    # NOTE: ensure builder(s) in packer templates can use 'HTTP' as 
    # a configuration option
    cp "${WORKSPACE}/${OS_BUILD_CONFS_REPO_NAME}/${OS_BUILD_CONF_NAME}" "$PACKER_HTTP_PATH"
    cp "${WORKSPACE}/${SHELL_PROVISIONERS_REPO_NAME}/${SHELL_PROVISIONER_NAME}" "$PACKER_SHELL_PROVISIONER_PATH"
    cp "${WORKSPACE}/${SHELL_PROVISIONERS_REPO_NAME}/${SHELL_PROVISIONERS_ENV_FILE_NAME}" "$PACKER_BUILD_ROOT_PATH"
    cp "${WORKSPACE}/${PACKER_BUILD_TEMPLATES_REPO_NAME}/${PACKER_BUILD_TEMPLATE_NAME}" "$PACKER_BUILD_ROOT_PATH"
    cp "${WORKSPACE}/${PACKER_BUILD_TEMPLATES_REPO_NAME}/${PACKER_BUILD_EVALUSERVARS_NAME}" "$PACKER_BUILD_ROOT_PATH"
    cp "$PACKERBUILDS_CONF_PATH" "$PACKER_HTTP_PATH"
    cd "$PACKER_BUILD_ROOT_PATH" || return 1

    # shellcheck disable=1090
    # NOTE: packer templates will have placeholders in them. These will be
    # evaluated based on env vars in the current env.
    source "$PACKER_BUILD_EVALUSERVARS_NAME"
    "$PACKER_BUILD_EVALUSERVARS_NAME"

    # record env vars into a file ==> PACKERBUILDS_CONF_PATH
    if [ -n "$RECORD_BUILDENV_VARS" ]; then
        read -r -a ENV_VAR_NAME_ARR <<< "$RECORD_BUILDENV_VARS"
        for env_var in "${ENV_VAR_NAME_ARR[@]}"; do
            echo "$env_var: ${!env_var}" >> "${PACKER_HTTP_PATH}/$(basename "${PACKERBUILDS_CONF_PATH}")"
        done
    fi

    if [ -z "$DRY_RUN" ]; then
        "$PACKER_EXE" build -only "$PACKER_BUILDER" "$PACKER_BUILD_TEMPLATE_NAME"
    fi

    return 0
}
